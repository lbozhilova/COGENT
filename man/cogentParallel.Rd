% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mainFunctions.R
\name{cogentParallel}
\alias{cogentParallel}
\title{Multiple COGENT calls, executed in parallel}
\usage{
cogentParallel(df, netwkFun, nodeFun = NULL, repCount = 100,
  threadCount = 4, propShared = 0, align = FALSE,
  nodeModes = "all", use = "complete.obs", method = "pearson",
  k.or.p = 0.1, scale = FALSE)
}
\arguments{
\item{df}{A COGENT-compatible data frame with rows corresponding to genes and
columns corresponding to samples. A column called Name containing gene
names is expected.}

\item{netwkFun}{A function mapping a COGENT-compatible data frame to an
adjacency matrix.}

\item{nodeFun}{A function calculating node metrics from an adjacency matrix.
Defaults to NULL.}

\item{repCount}{Number of repetitions.}

\item{threadCount}{Number of threads to use.}

\item{propShared}{Proportion of samples (from the input \code{df}) to be
shared across the two random split.}

\item{align}{Logical; Whether to align the two outputs of \code{netwkFun}.
Only set to TRUE if \code{netwkFun()} doesn't preserve gene order.}

\item{nodeModes}{Which modes of comparison to use for node metrics. This
should be either \code{"all"} or a subset of \{\code{"cor"}, \code{"ksim"},
\code{"L2"}\}. Ignored if \code{nodeFun=NULL}.}

\item{use}{Further argument for node comparison, see
\code{\link[stats]{cor}}.}

\item{method}{Further argument for node comparison, see
\code{\link[stats]{cor}}.}

\item{k.or.p}{Further argument for node comparison, see
\code{\link{calculateKSimilarity}}.}

\item{scale}{Further argument for node comparison, see
\code{\link{calculateEuclideanDistance}}.}
}
\value{
A data frane summarising results. See \link{cogentSingle} for details.
  \code{localSimilarity} is reported as the average over all ndoes.
}
\description{
\code{cogentParallel} will repeatedly randomly split a given gene expression
data frame in two sample groups, construct a network from each group, and
measure network similarity. It will do so by calling \code{cogentSingle} in
parallel. To be used when network construction is slow and not parallelised.
}
\examples{
# Generate some expression data
df <- as.data.frame(matrix(runif(500), nrow=10, ncol=50))
df <- cbind(Name=LETTERS[1:10], df)
# Construct co-expression networks by thresholding the Pearson correlation
# coefficient at 0.20.
foo <- function(df){
 A <- cor(t(df[,colnames(df)!="Name"]))
 A <- 1*(A>0.20)
 return(A)
}
# Use the degree as a node metric
fooNode <- function(x) rowSums(x)
# Calculate stability:
## Without node metric comparison, on two threads
cogentParallel(df, foo, threadCount=2)
## With all types of node metric comparison
cogentParallel(df, foo, fooNode, threadCount=2)

}
