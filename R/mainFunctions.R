#############################
##### COGENT: FUNCTIONS ######
#############################

#' Single COGENT call
#'
#' \code{cogentSingle()} will randomly split a gene expression data frame
#' \code{df} in two, construct two separate adjacency matrices by applying the
#' \code{netwkFun()} function to each partition and compare the results.
#'
#' @param df A COGENT-compatible data frame with rows corresponding to genes and
#'  columns corresponding to samples. A column called Name containing gene
#'  names is expected.
#' @param netwkFun A function mapping a COGENT-compatible data frame to an
#'   adjacency matrix.
#' @param nodeFun A function calculating node metrics from an adjacency matrix.
#'   Defaults to NULL.
#' @param propShared Proportion of samples (from the input \code{df}) to be
#'   shared across the two random split.
#' @param align Logical; Whether to align the two outputs of \code{netwkFun}.
#'   Only set to TRUE if \code{netwkFun()} doesn't preserve gene order.
#' @param nodeModes Which modes of comparison to use for node metrics. This
#'   should be either \code{"all"} or a subset of \{\code{"cor"}, \code{"ksim"},
#'   \code{"L2"}\}. Ignored if \code{nodeFun=NULL}.
#' @param use Further argument for node comparison, see
#'   \code{\link[stats]{cor}}.
#' @param method Further argument for node comparison, see
#'   \code{\link[stats]{cor}}.
#' @param k.or.p Further argument for node comparison, see
#'   \code{\link{calculateKSimilarity}}.
#' @param scale Further argument for node comparison, see
#'   \code{\link{calculateEuclideanDistance}}.
#'
#' @return The result is a list of similarity measures of the two gene
#'   expression networks generated by randomly splitting the samples in two
#'   groups. If \code{nodeFun=NULL} this includes:
#'   \itemize{
#'   \item \code{nodeCount} The number of non-isolated genes across the two
#'   networks.
#'   \item \code{globalSimilarity} The weighted Jaccard index of the edge
#'   sets of the two networks.
#'   \item \code{localSimilarity} The weighted Jaccard index for
#'   each gene neighbourhood.
#'   }
#'   If a node metric has been specified, this is also calculated and network
#'   similarity is measured with respect to the metric. A subset of the
#'   following metrics is returned in addition to the network metric:
#'   \itemize{
#'   \item \code{corSimilarity} The correlation coefficient between the two
#'   node metric vectors.
#'   \item \code{ksimSimilarity} The rank k-similarity between the two node
#'   metric vectors.
#'   \item \code{L2Distance} The Euclidean \emph{distance} between
#'   the two node metric vectors.
#'   }
#' @examples
#' # Generate some expression data
#' df <- as.data.frame(matrix(runif(500), nrow=10, ncol=50))
#' df <- cbind(Name=LETTERS[1:10], df)
#' # Construct co-expression networks by thresholding the Pearson correlation
#' # coefficient at 0.20.
#' foo <- function(df){
#'     A <- cor(t(df[,colnames(df)!="Name"]))
#'     A <- 1*(A>0.20)
#'     return(A)
#' }
#' # Use the degree as a node metric
#' fooNode <- function(x) rowSums(x)
#' # Calculate stability:
#' ## Without node metric comparison
#' cogentSingle(df, foo)
#' ## With all types of node metric comparison
#' cogentSingle(df, foo, fooNode)
#' ## With node metric comparison using Spearman correlation
#' ## and rank k-similarity
#' cogentSingle(df, foo, fooNode, nodeModes=c("cor", "ksim"), method="spearman")
#'
#' @export
cogentSingle <- function(df, netwkFun, nodeFun=NULL, propShared=0, align=FALSE, nodeModes="all",
                         use="complete.obs", method="pearson", k.or.p=0.1, scale=FALSE){
  check <- checkExpressionDF(df)
  check <- checkFun(netwkFun)
  dfList <- splitExpressionData(df, propShared)
  if (class(netwkFun)=="character")
    A <- lapply(dfList, function(x) do.call(netwkFun, list(x))) else
      A <- lapply(dfList, netwkFun)
  edgeSimilarity <- getEdgeSimilarity(A, align)
  if (is.null(nodeFun))
    return(edgeSimilarity)
  check <- checkFun(nodeFun)
  if (class(nodeFun)=="character")
    D <- lapply(A, function(x) do.call(nodeFun, list(x))) else
      D <- lapply(A, nodeFun)
  if (nodeModes[1]=="all")
    nodeModes <- c("cor", "ksim", "L2")
  nodeSimilarity <- vector("list", length(nodeModes))
  names(nodeSimilarity) <- paste0(nodeModes, "Similarity") # TODO: L2 should be L2 distance
  if ("cor" %in% nodeModes)
    nodeSimilarity$corSimilarity <- getNodeSimilarity(D, "cor", align, use, method)
  if ("ksim" %in% nodeModes)
    nodeSimilarity$ksimSimilarity <- getNodeSimilarity(D, "ksim", align, k.or.p)
  if ("L2" %in% nodeModes){
    nodeSimilarity$L2Similarity <- getNodeSimilarity(D, "L2", align, scale)
    names(nodeSimilarity)[names(nodeSimilarity)=="L2Similarity"] <- "L2Distance"
  }
  return(c(edgeSimilarity, nodeSimilarity))
}

#' Multiple COGENT calls, executed on a single thread
#'
#' \code{cogentLinear} will repeatedly randomly split a given gene expression
#' data frame in two sample groups, construct a network from each group, and
#' measure network similarity. It will do so by calling \code{cogentSingle}
#' repeatedly. To be used when network construction is either fast, or slow
#' but parallelised.
#' @inheritParams cogentSingle
#' @param repCount Number of repetitions.
#'
#' @return A data frane summarising results. See \link{cogentSingle} for details.
#'   \code{localSimilarity} is reported as the average over all ndoes.
#'
#' @examples
#' # Generate some expression data
#' df <- as.data.frame(matrix(runif(500), nrow=10, ncol=50))
#' df <- cbind(Name=LETTERS[1:10], df)
#' # Construct co-expression networks by thresholding the Pearson correlation
#' # coefficient at 0.20.
#' foo <- function(df){
#'  A <- cor(t(df[,colnames(df)!="Name"]))
#'  A <- 1*(A>0.20)
#'  return(A)
#' }
#' # Use the degree as a node metric
#' fooNode <- function(x) rowSums(x)
#' # Calculate stability:
#' ## Without node metric comparison
#' cogentLinear(df, foo, repCount=10)
#' ## With all types of node metric comparison
#' cogentLinear(df, foo, fooNode, repCount=10)
#'
#' @export
cogentLinear <- function(df, netwkFun, nodeFun=NULL, repCount=100,
                         propShared=0, align=FALSE, nodeModes="all",
                         use="complete.obs", method="pearson", k.or.p=0.1, scale=FALSE){
  repeatsList <- replicate(repCount, cogentSingle(df, netwkFun, nodeFun, propShared, align, nodeModes,
                                                   use, method, k.or.p, scale), simplify=FALSE)
  repeatsDF <- do.call("rbind", repeatsList)
  repeatsDF[,"localSimilarity"] <- sapply(repeatsDF[,"localSimilarity"], mean)
  repeatsDF <- apply(repeatsDF, 2, simplify2array)
  repeatsDF <- as.data.frame(repeatsDF)
  return(repeatsDF)
}

#' Multiple COGENT calls, executed in parallel
#'
#' \code{cogentParallel} will repeatedly randomly split a given gene expression
#' data frame in two sample groups, construct a network from each group, and
#' measure network similarity. It will do so by calling \code{cogentSingle} in
#' parallel. To be used when network construction is slow and not parallelised.
#'
#' @inheritParams cogentSingle
#' @param repCount Number of repetitions.
#' @param threadCount Number of threads to use.
#'
#' @return A data frane summarising results. See \link{cogentSingle} for details.
#'   \code{localSimilarity} is reported as the average over all ndoes.
#'
#' @examples
#' # Generate some expression data
#' df <- as.data.frame(matrix(runif(500), nrow=10, ncol=50))
#' df <- cbind(Name=LETTERS[1:10], df)
#' # Construct co-expression networks by thresholding the Pearson correlation
#' # coefficient at 0.20.
#' foo <- function(df){
#'  A <- cor(t(df[,colnames(df)!="Name"]))
#'  A <- 1*(A>0.20)
#'  return(A)
#' }
#' # Use the degree as a node metric
#' fooNode <- function(x) rowSums(x)
#' # Calculate stability:
#' ## Without node metric comparison, on two threads
#' cogentParallel(df, foo, threadCount=2)
#' ## With all types of node metric comparison
#' cogentParallel(df, foo, fooNode, threadCount=2)
#'
#' @export
cogentParallel <- function(df, netwkFun, nodeFun=NULL, repCount=100, threadCount=4,
                           propShared=0, align=FALSE, nodeModes="all",
                           use="complete.obs", method="pearson", k.or.p=0.1, scale=FALSE){
  repeatsList <- mclapply(1:repCount, function(x) cogentSingle(df, netwkFun, nodeFun, propShared, align, nodeModes,
                                                              use, method, k.or.p, scale),
                           mc.cores=threadCount, mc.cleanup=TRUE)
  repeatsDF <- do.call("rbind", repeatsList)
  repeatsDF[,"localSimilarity"] <- sapply(repeatsDF[,"localSimilarity"], mean)
  repeatsDF <- apply(repeatsDF, 2, simplify2array)
  repeatsDF <- as.data.frame(repeatsDF)
  return(repeatsDF)
}
